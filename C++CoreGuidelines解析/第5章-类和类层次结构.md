# 类和类的层次结构

类和类的层次结构规则概览：

- [类和类的层次结构](#类和类的层次结构)
  - [5.1 概要规则](#51-概要规则)
    - [C.1 把相关的数据组织到结构（struct 或 class）中](#c1-把相关的数据组织到结构struct-或-class中)
    - [C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct](#c2-当类具有不变式时使用-class如果数据成员可以独立变化则使用-struct)
    - [C.3 在类中体现出接口和实现之间的区别](#c3-在类中体现出接口和实现之间的区别)
    - [C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员](#c4-仅当函数需要直接访问类的内部表示时才把它变成成员)
    - [C.5 将辅助函数与它们支持的类放在同一个命名空间中](#c5-将辅助函数与它们支持的类放在同一个命名空间中)
    - [C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量](#c7-不要在一条语句里定义类或枚举的同时声明该类型的变量)
    - [C.8 如果有任何非公开成员，就使用 class 而不是 struct](#c8-如果有任何非公开成员就使用-class-而不是-struct)
    - [C.9 尽量减少成员的暴露](#c9-尽量减少成员的暴露)
  - [5.2 具体类型](#52-具体类型)
    - [C.10 优先使用具体类型而不是类层次结构](#c10-优先使用具体类型而不是类层次结构)
    - [C.11 让具体类型规范化](#c11-让具体类型规范化)
  - [5.3 构造函数、赋值运算符和析构函数](#53-构造函数赋值运算符和析构函数)
    - [预置操作](#预置操作)
    - [C.20 如果能避免定义默认操作，那么就这么做](#c20-如果能避免定义默认操作那么就这么做)

类是一种用户定义类型，程序员可以为其指定表示方法、操作和接口。类的层次结构被用来组织相关的结构。

C++ Core Guidelines 中大约有100条关于用户定义类型的规则。

Guidelines 先给出了一些概要规则，然后深入讨论了下面的特殊规则：

- 具体类型
- 构造函数、赋值和析构函数
- 类的层次结构
- 重载和运算符重载
- 联合体

下面的 8 条概要规则为特殊规则提供了背景。

## 5.1 概要规则

概要规则相当简短，没有涉及太多细节。它们对类概括提供了有价值的深刻见解。

> **class（类）和struct（结构体）之间的语法差异**
> 本节经常提到类和结构体之间的语义区别。首先。语法上的差异是什么？差异很小，但很重要：
> - 在结构体中，所有成员默认为 public（公开）；类为（private）私有。
> - 继承情况也是如此。结构体默认继承权限为 public，类为 private。

**除此之外，二者在语言语法层面完全一致**。

### C.1 把相关的数据组织到结构（struct 或 class）中

如何改进 draw 的接口？

```cpp
void draw(int fromX, int fromY, int toX, int toY);
```

不明显的是，这些 int 代表了什么。因此，调用函数的时候参数顺序可能会出错。可以对比一下上面的 draw 和下面的新函数：

```cpp
void draw(Point from, Point to);
```

通过将相关元素放在结构体中，函数签名变得可以自我描述，因此，比起之前的函数，新函数更不容易出错。

> 类对象的构造函数也可以用来检测参数的合法性，不过这里的 Point 类型倒是没啥好检测的了。

### C.2 当类具有不变式时使用 class；如果数据成员可以独立变化，则使用 struct

>不变式（Invariant）是一个在程序执行过程中永远保持成立的条件。不变式在检测程序是否正确方面非常有用。例如编译器优化就用到了不变式。

类的不变式是用于约束类的实例的不变式。成员函数必须使这个不变式保持成立。
不变式约束了类的实例的可能取值。

这是 C++ 中一个常见的问题：*什么时候该使用 class，什么时候该用 struct？*

C++ Core Guidelines 给出了以下建议。**如果类有不变式，就使用 class**。

> **如果类有一个需要在程序执行过程中永远保持成立的条件，就使用 class**。

一个可能的类的不变式是，（y，m，d）可表示一个有效的日期。

```cpp
struct Pair{  //成员可以独立变化
    string name;
    int volume;
};

class Date{
public:
    //校验 {yy，mm，dd}是不是合法的日期并进行初始化
    Date(int yy, Month mm, char dd);
    // ...
private:
    int y;
    Month m;
    char d;    //日
}
```

类的不变式在构造函数中被初始化和检查。数据类型 Pair 没有不变式，因为名称（name）和体积（volume）的所有值都是有效的。Pair 是简单的数据持有者，不需要显式提供构造函数。

> 值得一提的是，很多库并没有很好的遵守，我们举例 [QPoint](https://doc.qt.io/qt-6/qpoint.html)，[源码](https://codebrowser.dev/qt5/qtbase/src/corelib/tools/qpoint.h.html)。

QPoint 显然是没有不变式，它的成员（xp，yp）所有的值都是有效的，但它依旧使用的是 class。
以及，它没有将它的数据成员设置为 public，反而提供了愚蠢的 6 个成员函数进行访问：`rx，ry，x，y，setX，setY`。

### C.3 在类中体现出接口和实现之间的区别

类的公开成员函数是类的接口，私有部分则是实现。

```cpp
类的公开成员函数是类的接口，私有部分则是实现。
class Date{
public:
    Date();
    //校验 {yy，mm，dd}是不是合法的日期并进行初始化
    Date(int yy, Month mm, char dd);
    int day()const;
    Month month()const;
    // ...
private:
    // ... 具体的内部表示
};
```

从可维护性的角度看，可以修改 Date 类的实现，而毫不影响该类的使用者。

> 就是说面向对象的**封装**，数据和操作数据的方法（即类的接口）捆绑在一起，并对外部隐藏对象的内部状态。这样可以确保类的接口有效性和不变性。

### C.4 仅当函数需要直接访问类的内部表示时，才把它变成成员

如果一个函数不需要访问类的内部结构，它就不应该是成员。这样的话，你会得到松耦合，而且类的内部结构的改变不会影响辅助函数。

> 一个函数不修改类的私有数据成员，它就不该是成员

```cpp
class Date{
    // ... 相对小的接口 ...
};

//辅助函数
Date next_weekday(Date);
bool operator == (Date, Date);
```

运算符 `=`、`()`、`[]`、`->` 必须是类的成员。

> 事实上这条规则没那么好遵守，有非常多的额外情况，英文原书和我们当前描写的都太少了。可以看[英文文档](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class)，或[国人翻译](https://github.com/lynnboy/CppCoreGuidelines-zh-CN/blob/master/CppCoreGuidelines-zh-CN.md#c4-仅当函数直接访问类的内部表示时才让函数作为其成员)。

### C.5 将辅助函数与它们支持的类放在同一个命名空间中

辅助函数应该在类的命名空间中，因为它是类的接口的一部分。与成员函数相反，辅助函数不需要直接访问类的内部表示。

```cpp
namespace Chrono{ // 在这里放置跟时间有关的服务
    class Date { /* ... */ };

    // 辅助函数：
    bool operator == (Date, Date);
    Date next_weekday(Date);
    // ...
}
...
if (date1 == date2) { ... //（1）
```

由于有[实参依赖查找](https://zh.cppreference.com/w/cpp/language/adl)（argument-dependent lookup，ADL），比较 date1 == date2 将额外查找 Chrono 命名空间中的相等运算符。ADL 对于重载的运算符尤其重要，如输出运算符<<。

### C.7 不要在一条语句里定义类或枚举的同时声明该类型的变量

若在一条语句里定义类或枚举并同时声明其他类型的变量，会引起混淆，因此应该避免。

```cpp
// 不好
struct Date { /*...*/ } date { /*...*/ };

// 好
struct Date{ /*...*/ };
Date date{ /*...*/ };
```

### C.8 如果有任何非公开成员，就使用 class 而不是 struct

明确某事被隐藏/抽象。这是一个有用的约定。

>除此之外可能还有很多乱七八糟的理由，但总而言之，就是这样，**约定**。

### C.9 尽量减少成员的暴露

数据隐藏和**封装**是面向对象类设计的基石之一：你将类中的成员封装起来，只允许通过公共成员函数进行访问。你的类可能有两种接口：一种是用于外部的 public 接口，一种是用于派生类的 protected 接口。其余成员都应该属于 private。

> 封装。信息隐藏。最大限度地减少意外访问的机会。这简化了维护。
> 需要注意的是，也不要什么成员都给封装了，这样会走上 java 的邪路，`get`、`set` ...

## 5.2 具体类型

本节只有两条规则，但引入了具体类型和规范类型这两个术语。
根据 C++ Core Guidelines：

**具体类型是“最简单的一种类”**。它常常被称作值类型，不属于某个类型层次结构的一部分 。

**规范类型是一种“行为类似于 int”的类型**，因此，它必须支持拷贝和赋值、相等比较，以及可交换。更正式的说法是，一个规范类型 X 行为上像 int，支持下列操作。

- 默认构造：X()
- 拷贝构造：X(const X&)
- 拷贝赋值：operator = (const X&)
- 移动构造：X(X&&)
- 移动赋值：operator = (X&&)
- 析构：~X()
- 交换操作：swap(X&, X&)
- 相等运算符：operator ==(const X&, const X&)

### C.10 优先使用具体类型而不是类层次结构

如果没有需要类层次结构的用例，就使用具体类型。具体的类型更容易实现，更小，且更快。不必担心继承、虚性、引用或指针，包括内存分配和释放。不会有虚派发，因此也没有运行期开销。

长话短说：应用 [KISS](https://en.wikipedia.org/wiki/KISS_principle) 原则（“keep it simple,stupid”原则，保持简单，让傻瓜都能理解）。你的类型行为像普通数值一样。

### C.11 让具体类型规范化

规范类型（如 int）易于理解，它们本身就很直观。这意味着：

- 如果你有一个具体类型，可以考虑将它升级为规范类型。

内置类型（如 int 或 double）是规范类型，而用户定义类型（如 std::string）或容器（std::vector 或 std::unordered_map）也是如此。

C++20 支持 regular （规范）概念。

## 5.3 构造函数、赋值运算符和析构函数

这一节讨论构造函数、赋值运算符和析构函数，在本章范围内，此类规则的数量是目前为止最多的。它们控制着对象的生命周期：创建、拷贝、移动和销毁。简而言之，我们把它们称为“六大”。下面是这六个特殊的成员函数。

- 默认构造函数：X()
- 拷贝构造函数：X(const X&)
- 拷贝赋值运算符：operator = (const X&)
- 移动构造：X(X&&)
- 移动赋值运算符：operator = (X&&)
- 析构函数：~X()

编译器可以为这“六大”生成默认实现。本节从有关默认操作的规则开始；接着是有关构造函数、拷贝和移动操作以及析构函数的规则；最后是不属于前四类的其他默认操作的规则。

根据默认构造函数的声明，你可能有这样的印象：默认构造函数不需要参数。这是不对的。默认构造函数可以在没有参数的情况下被调用，但它可能每个参数都有默认值。

### 预置操作

默认情况下，如果需要，编译器可以生成“六大”。可以定义这六个特殊的成员函数，但也可明确用 = default（预置）来要求编译器提供它们，或者用 = delete（弃置）来删除它们。

### C.20 如果能避免定义默认操作，那么就这么做

这一规则也被称为“零法则”。这意味着你可以通过使用有合适的拷贝/移动语义的类型，来避免自行编写构造函数、拷贝/移动构造函数、赋值运算符或析构函数。有合适的拷贝/移动语义的类型包括规范类型，如内置类型 bool 或 double，也包括标准模板库（STL）的容器，如 std::vector 或 std::string。

```cpp
class Named_map{
public:
    // ... 没有声明任何默认操作 ...
private:
    std::string name;
    std::map<int, int> rep;
};

Named_map mm;        // 默认构造
Named_map nm2 {nm};  // 拷贝构造
```

默认构造和拷贝构造之所以有效，是因为 std::string 和 std::map 已经定义了相应的操作。

- **编译器所自动生成的拷贝构造函数会调用当前类所有成员的拷贝构造函数**。

> 特殊成员函数都是这样，不局限于拷贝构造，这个其实以前在 [**P.9**](第2章-理念.md) 提起过。（另外强调一下，这些话全说的是类类型）

```cpp
try{

}catch(auto){

}
```